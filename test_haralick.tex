% Please do NOT edit this file.
% It has been automatically generated
% by a perl script from the original cxx sources
% in the Insight/Examples directory

% Any changes should be made in the file
% src/test_haralick.c


The source code for this section can be found in the file \verb|test_haralick.c|.\\  Haralick edge detectors, main C file.\\
  
  Parameters:
	\begin{itemize}
		\item \texttt{input\_image} - Input image.
		\item \texttt{rhozero} - Threshold for the Haralick condition $|\frac{C_2}{2C_3}|\leq\rho_0$.
		\item \texttt{padding\_method} - Padding method flag (in convolution): 0 means zero-padding, 1 means image boundary reflection.
		\item \texttt{output\_image} - Output image (edges).
	\end{itemize}

	Includes:
\small
\begin{lstlisting}
	#include "iio.c"
	#include "2dconvolution.c"
	#include <time.h>
\end{lstlisting}
\vspace{1ex}
\normalsize
	\vspace{0.5cm}
	\Large{Main function} \\
\small
\begin{lstlisting}
int main(int argc, char *argv[]) {
\end{lstlisting}
\vspace{1ex}
\normalsize
	Load input image (using \textit{iio}): \\
\small
\begin{lstlisting}
		int w, h, pixeldim;
		float *im_orig = iio_read_image_float_vec(argv[1], &w, &h, &pixeldim);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Grayscale conversion (if necessary): explained in \ref{app:marr-hildreth}. \\ \\
	Masks calculated by 2-d fitting (using LS) with the function: 
	$$
	f(x,y) = k_1 + k_2x + k_3y + k_4x^2 + k_5xy + k_6*y^2 + k_7x^3 + k_8x^2y + k_9xy^2 + k_{10}y^3 \\
	$$
\small
\begin{lstlisting}
		double masks[10][25] = { {   425,   275,  225,  275,  425,   
									 275,   125,   75,  125,  275,   
                                     225,    75,   25,   75,  225,   
									 275,   125,   75,  125,  275,   
									 425,   275,  225,  275,  425},
								 { -2260,  -620,    0,  620,  2260, 
								   -1660,  -320,    0,  320,  1660, 
								   -1460,  -220,    0,  220,  1460,
                                   -1660,  -320,    0,  320,  1660, 
                                   -2260,  -620,    0,  620, 2260},
								// matrix continues, too large to display in documentation.
\end{lstlisting}
\vspace{1ex}
\normalsize
	Initialise edge image using \texttt{calloc}:
\small
\begin{lstlisting}
		float *edges = calloc(w*h,sizeof(float));
\end{lstlisting}
\vspace{1ex}
\normalsize
	Padding: a larger auxiliar image \texttt{aux} is required to compute the coefficients $k_1$ to $k_{10}$ in every pixel of the original image. \\
	Two different methods are implemented: zero-padding (\texttt{padding\_method}$=0$) and reflection of original image (\texttt{padding\_method}$=1$).
\small
\begin{lstlisting}
		int wx = (w+8);
		int hx = (h+8);
		double *aux = calloc(wx*hx,sizeof(double));
		int fila,col;
		int imax = wx*hx;
		if (padding_method == 0) {
			for(i=0;i<imax;i++){
				fila = (int)(i/wx);
				col = i-(wx*fila);	
				if ( (fila>=4)&&(col>=4)&&(fila<h+4)&&(col<w+4) ) {
					aux[i] = im[(col-4)+(w*(fila-4))];
				}
			}
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
\small
\begin{lstlisting}
		if (padding_method == 1) {
			int fila_refl, col_refl;
			for(i=0;i<imax;i++){
				fila = (int)(i/wx);
				col = i-(wx*fila);
				if (fila<4) {
					fila_refl = 7 - fila;
					if (col<4) { //zone1
						col_refl = 7 - col;
					} else if (col<w+4) {	//zone2
						col_refl = col;
					} else { //zone3
						col_refl = 2*w + 7 - col;
					}
				} else if (fila<h+4) {
					fila_refl = fila;
					if (col<4) { //zone4
						col_refl = 7 - col;
					} else if (col<w+4) { //image
						col_refl = col;
					} else { //zone5
						col_refl =  2*w + 7 - col;
					}
				} else {
					fila_refl = 2*h + 7 - fila;
					if (col<4) { //zone6
						col_refl =	7 - col;
					} else if (col<w+4) {	//zone7
						col_refl = col;
					} else { //zone8
						col_refl =  2*w + 7 - col;
					}
				}
				aux[i] = im[(col_refl-4)+(w*(fila_refl-4))];
			} //for
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Haralick algorithm: coefficients $k_1$ to $k_{10}$ are computed in every pixel of the original image 
	(using the function \texttt{get\_neighbors\_offset} to get the index offsets of the neighbor pixels and 
	the function \texttt{get\_neighborhood} to get the neighborhood of a pixel using those index offsets). 
	Once the coefficients are calculated, are computed
	$$
	C_2 = \frac{k_2^2k_4 + k_2k_3k_5 + k_3^2k_6}{k_2^2 + k_3^2}
	$$
	and
	$$
	C_3 = \frac{k_2^3k_7 + k_2^2k_3k_8 + k_2k_3^2k_9 + k_3^3k_{10}}{(\sqrt{k_2^2 + k_3^2})^3},
	$$
	and then the edge condition is evaluated in every pixel; $|\frac{C_2}{2C_3}|\leq\rho_0$. \\
\small
\begin{lstlisting}
		int i_zp, u, v, num_edges;
		num_edges = 0;
		double k[10];
		int *offsets = get_neighbors_offset(wx, 5);
		double acum;
		double C2, C3, denom, sintheta, costheta;
		for(fila=0;fila<h;fila++){
			for(col=0;col<w;col++){
				i = col + w*fila;				// original image & edges image index
				i_zp = (col+4) + wx*(fila+4);	// padded image index
				double *neighborhood = get_neighborhood(aux, i_zp, 5, offsets);
				// k1 to k10 (note: k1 (u=0) is not necessary)
				for(u=0;u<10;u++){
					acum = 0;
					for(v=0;v<25;v++){
						acum += neighborhood[v]*masks[u][v];
					}
					k[u] = acum;
				}
				// compute C2 and C3
				denom = sqrt( k[1]*k[1] + k[2]*k[2] );
				sintheta = - k[1] / denom;
				costheta = - k[2] / denom;
				C2 = k[3]*sintheta*sintheta + k[4]*sintheta*costheta + k[5]*costheta*costheta;
				C3 = k[6]*sintheta*sintheta*sintheta + k[7]*sintheta*sintheta*costheta +
					 k[8]*sintheta*costheta*costheta + k[9]*costheta*costheta*costheta;
				//if ((fabs(C2 / (3*C3))<=rhozero)&&(C3<=0)) {
				if ((fabs(C2 / (3*C3))<=rhozero)) {
					edges[i] = 255;
					num_edges += 1;
				}
				// free neighborhood
				free_neighborhood(neighborhood);
			}
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Save output image (using \textit{iio}): \\
\small
\begin{lstlisting}
		iio_save_image_float_vec(argv[4], edges, w, h, 1);
\end{lstlisting}
\vspace{1ex}
\normalsize
