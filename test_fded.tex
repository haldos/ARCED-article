% Please do NOT edit this file.
% It has been automatically generated
% by a perl script from the original cxx sources
% in the Insight/Examples directory

% Any changes should be made in the file
% src/test_fded.c


The source code for this section can be found in the file \verb|test_fded.c|.\\  First derivative edge detectors (Roberts, Prewitt and Sobel), main C file.\\
  
  Parameters:
	\begin{itemize}
		\item \texttt{input\_image} - Input image.
		\item \texttt{threshold} - Threshold for gradient image ($0\leq th \leq 1$).
		\item \texttt{padding\_method} - Padding method flag (in convolution): 0 means zero-padding, 1 means image boundary reflection.
	\end{itemize}

	\textit{Note: Output images are saved with the filenames ``\texttt{roberts.png}'', ``\texttt{prewitt.png}'' and ``\texttt{sobel.png}''.} \\

	Includes:
\small
\begin{lstlisting}
	#include "iio.c"
	#include "2dconvolution.c"
	#include <time.h>
\end{lstlisting}
\vspace{1ex}
\normalsize
  Macros:
\small
\begin{lstlisting}
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#define THRESHOLD(x, th) (((x) > (th)) ? (255) : (0))
\end{lstlisting}
\vspace{1ex}
\normalsize
	\vspace{0.5cm}
	\Large{Main function} \\
\small
\begin{lstlisting}
int main(int argc, char *argv[]) {
\end{lstlisting}
\vspace{1ex}
\normalsize
	Load input image (using \textit{iio}): \\
\small
\begin{lstlisting}
		int w, h, pixeldim;
		float *im_orig = iio_read_image_float_vec(argv[1], &w, &h, &pixeldim);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Grayscale conversion (if necessary): explained in \ref{sec:grayscale}. \\ \\
	Define the normalized Roberts, Prewitt and Sobel operators: \\
	(We use $3\times 3$ operators)
	\begin{itemize}
		\item	Roberts:
				$$
				R_1 = \begin{bmatrix} -1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0 \end{bmatrix}
				$$
				$$
				R_2 = \begin{bmatrix} 0 & -1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}
				$$
		\item	Prewitt:
				$$
				P_1 = \begin{bmatrix} \frac{-1}{6} & \frac{-1}{6} & \frac{-1}{6} \\ 0 & 0 & 0 \\ \frac{1}{6} & \frac{1}{6} & \frac{1}{6} \end{bmatrix}
				$$
				$$
				P_2 = \begin{bmatrix} \frac{-1}{6} & 0 & \frac{1}{6} \\ \frac{-1}{6} & 0 & \frac{1}{6} \\ \frac{-1}{6} & 0 & \frac{1}{6} \end{bmatrix}
				$$
		\item	Sobel:
				$$
				S_1 = \begin{bmatrix} \frac{-1}{8} & \frac{-1}{4} & \frac{-1}{8} \\ 0 & 0 & 0 \\ \frac{1}{8} & \frac{1}{4} & \frac{1}{8} \end{bmatrix}
				$$
				$$
				S_2 = \begin{bmatrix} \frac{-1}{8} & 0 & \frac{1}{8} \\ \frac{-1}{4} & 0 & \frac{1}{4} \\ \frac{-1}{8} & 0 & \frac{1}{8} \end{bmatrix}
				$$
	\end{itemize}
\small
\begin{lstlisting}
		double roberts_1[9] = {-1, 0, 0, 0, 1, 0, 0, 0, 0};		// ROBERTS
		double roberts_2[9] = { 0,-1, 0, 1, 0, 0, 0, 0, 0};		// OPERATORS
		//---------------------------------------------------------------------------------
		double prewitt_1[9] = {-1,-1,-1, 0, 0, 0, 1, 1, 1};		// PREWITT
		double prewitt_2[9] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};		// OPERATORS
		//---------------------------------------------------------------------------------
		double sobel_1[9] = {-1,-2,-1, 0, 0, 0, 1, 2, 1};		// SOBEL
		double sobel_2[9] = {-1, 0, 1,-2, 0, 2,-1, 0, 1};		// OPERATORS
		//---------------------------------------------------------------------------------
		for (z=0;z<9;z++) {										// NORMALIZATION
			roberts_1[z] /= sqrt(2);
			roberts_2[z] /= sqrt(2);
			prewitt_1[z] /= sqrt(6);
			prewitt_2[z] /= sqrt(6);
			sobel_1[z] /= sqrt(12);
			sobel_2[z] /= sqrt(12);
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	The input image is convolved with the defined operatos, using the \texttt{conv2d} function in \texttt{2dconvolution.c}:
\small
\begin{lstlisting}
		int padding_method = atoi(argv[3]);
		double *im_r1 = conv2d(im, w, h, roberts_1, 3, padding_method);
		double *im_r2 = conv2d(im, w, h, roberts_2, 3, padding_method);
		double *im_p1 = conv2d(im, w, h, prewitt_1, 3, padding_method);
		double *im_p2 = conv2d(im, w, h, prewitt_2, 3, padding_method);
		double *im_s1 = conv2d(im, w, h, sobel_1, 3, padding_method);
		double *im_s2 = conv2d(im, w, h, sobel_2, 3, padding_method);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Allocate memory for final images:
\small
\begin{lstlisting}
		float *im_roberts = malloc(w*h*sizeof(float));
		float *im_prewitt = malloc(w*h*sizeof(float));
		float *im_sobel = malloc(w*h*sizeof(float));
\end{lstlisting}
\vspace{1ex}
\normalsize
	For each method, two images are obtained (one for each operator). Then the gradient magnitude image is constructed using $M=\sqrt{g_x^2+g_y^2}$. \\
	Also the absolute maximum value of the constructed images is computed, for each method. \\
\small
\begin{lstlisting}
		int i,j, fila, col;
		double max_r = 0;
		double max_p = 0;
		double max_s = 0;
		int imax = w*h;
		for (i=0;i<imax;i++){
			fila = (int)(i/w);
			col = i - w*fila + 1;
			fila += 1;
			j = col + (w+2)*fila;
			// Max in each case
			im_roberts[i] = sqrt(im_r1[j]*im_r1[j] + im_r2[j]*im_r2[j]);
			im_prewitt[i] = sqrt(im_p1[j]*im_p1[j] + im_p2[j]*im_p2[j]);
			im_sobel[i] = sqrt(im_s1[j]*im_s1[j] + im_s2[j]*im_s2[j]);
			// Absolute max
			max_r = MAX(max_r,im_roberts[i]);
			max_p = MAX(max_p,im_prewitt[i]);
			max_s = MAX(max_s,im_sobel[i]);
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Thresholded images of each method are created, using the THRESHOLD macro: \\
\small
\begin{lstlisting}
		float th = atof(argv[2]);
		for (i=0;i<imax;i++){
			im_roberts[i] = THRESHOLD(im_roberts[i],th*max_r);
			im_prewitt[i] = THRESHOLD(im_prewitt[i],th*max_p);
			im_sobel[i] = THRESHOLD(im_sobel[i],th*max_s);
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Save output image (using \textit{iio}): \\
\small
\begin{lstlisting}
		iio_save_image_float_vec("roberts.png", im_roberts, w, h, 1);
		iio_save_image_float_vec("prewitt.png", im_prewitt, w, h, 1);
		iio_save_image_float_vec("sobel.png", im_sobel, w, h, 1);
\end{lstlisting}
\vspace{1ex}
\normalsize
