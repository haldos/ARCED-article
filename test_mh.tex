% Please do NOT edit this file.
% It has been automatically generated
% by a perl script from the original cxx sources
% in the Insight/Examples directory

% Any changes should be made in the file
% src/test_mh.c


The source code for this section can be found in the file \verb|test_mh.c|.\\  Marr-Hildreth edge detector, main C file.\\
  
  Parameters:
	\begin{itemize}
		\item \texttt{input\_image} - Input image.
		\item \texttt{sigma} - Standard deviation $\sigma$ of the Gaussian kernel.
		\item \texttt{n} - Size $n$ of the Gaussian kernel ($n\times n$).
		\item \texttt{tzc} - Threshold in the Zero-Crossing calculation ($0\leq t_{zc}\leq 1$).
		\item \texttt{padding\_method} - Padding method flag (in convolution): 0 means zero-padding, 1 means image boundary reflection.
		\item \texttt{output\_image} - Output image (edges).
	\end{itemize}

	Includes:
\small
\begin{lstlisting}
	#include "iio.c"
	#include "gaussian_kernel.c"
	#include "2dconvolution.c"
	#include <time.h>
\end{lstlisting}
\vspace{1ex}
\normalsize
	\vspace{0.5cm}
	\Large{Main function} \\
\small
\begin{lstlisting}
int main(int argc, char *argv[]) {
\end{lstlisting}
\vspace{1ex}
\normalsize
	Load input image (using \textit{iio}): \\
\small
\begin{lstlisting}
		int w, h, pixeldim;
		float *im_orig = iio_read_image_float_vec(argv[1], &w, &h, &pixeldim);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Grayscale conversion (if necessary): \\
	First is allocated the memory for the grayscale image \texttt{im}, with
	the corresponding correct allocation check. Then the number of channels of the image is checked: if
	\texttt{pixeldim}=3, RGB image is assumed and conversion is needed, else, single channel image (grayscale) is assumed and
	no conversion is required.\\
	The computation of the gray intensity from RGB levels is:
	$$
	I = \frac{6968\times (\text{float})R + 23434\times (\text{float})G + 2366\times (\text{float})B}{32768} \\
	$$
  To perform this operation, a cast is made to float on the values ​​$R$, $G$ and $B$ of the original image. This can be slow, 
  but ensures the correct image conversion. \\
  These coefficients also ensure there is no saturation in the calculation, since $\frac{6968\times 255 + 23434\times 255 + 2366\times 255}{32768} = \frac{8355840}{32768} = 255$.
\small
\begin{lstlisting}
		double *im = malloc(w*h*sizeof(double));
		if (im == NULL){
			fprintf(stderr, "Out of memory...\n");
			exit(EXIT_FAILURE);
		}
		int z;
		int zmax = w*h;	
		if (pixeldim==3){
			for(z=0;z<zmax;z++){
				im[z] =  (double)(6968*im_orig[3*z] + 23434*im_orig[3*z + 1] 
													+ 2366*im_orig[3*z + 2])/32768;
			}
			fprintf(stderr, "images converted to grayscale\n");
		} else {
			for(z=0;z<zmax;z++){
				im[z] = (double)im_orig[z];
			}
			fprintf(stderr, "images are already in grayscale\n");
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Generate Gaussian kernel using the \texttt{gaussian\_kernel} function in \texttt{gaussian\_kernel.c}: \\
\small
\begin{lstlisting}
		double *kernel = gaussian_kernel(n,sigma);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Smooth input image with the Gaussian kernel previously generated, using the \texttt{conv2d} function in \texttt{2dconvolution.c}: \\
\small
\begin{lstlisting}
		double *im_smoothed = conv2d(im, w, h, kernel, n, padding_method);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Computation of the Laplacian of the smoothed image: \\
	A $3\times 3$ approximation of the laplacian operator is used: \\
	$$
	\begin{bmatrix}
		1 &  1 & 1 \\
		1 & -8 & 1 \\
		1 &  1 & 1 
	\end{bmatrix}
	$$
	Using the \texttt{conv2d} function, the \texttt{laplacian} image is obtained. \\
\small
\begin{lstlisting}
		double operator[9] = {1, 1, 1, 1, -8, 1, 1, 1, 1};
		double *laplacian = conv2d(im_smoothed, w+n-1, h+n-1, operator, 3, padding_method);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Now the maximum absolute value of the \texttt{laplacian} image is calculated. This value is required
	for thresholding in zero-crossing calculation. \\
\small
\begin{lstlisting}
		double max_l = 0;
		int p;
		int pmax = (w+n+1)*(h+n+1);
		for (p=0;p<pmax;p++){
			if (abs(laplacian[p])>max_l){
				max_l = abs(laplacian[p]);
			}
		}
\end{lstlisting}
\vspace{1ex}
\normalsize
	Zero-crossing: \\
	The image is explored, looking in every pixel a change of sign between neighboring opposite pixels.
 	In every pixel $p$ the funcion \texttt{get\_neighborhood} (in \texttt{2dconvolution.c}) is used to get the
	9 pixels of its neighborhood:
	$$
	\begin{bmatrix}
		p_{up,left}		& p_{up,middle}		& p_{up,right}		\\
		p_{middle,left}	& p					& p_{middle,right}	\\
		p_{down,left}	& p_{down,middle}	& p_{down,right}	
	\end{bmatrix}
	$$
	Then the pixel $p$ is marked as edge pixel if it occurs that:
	\begin{itemize}
	\item $sign(p_{up,left}) \neq sign(p_{down,right})$, or 
	\item $sign(p_{up,middle}) \neq sign(p_{down,middle})$, or 
	\item $sign(p_{up,right}) \neq sign(p_{down,left})$, or
	\item $sign(p_{middle,left}) \neq sign(p_{middle,right})$. \\
	\end{itemize}
\small
\begin{lstlisting}
		float *zero_cross = calloc(w*h,sizeof(float));		
						// this image will only content values 0 and 255
						// but float type is used for saving using iio.
		if (zero_cross == NULL){
			fprintf(stderr, "Out of memory...\n");
			exit(EXIT_FAILURE);
		}
		int ind_en_lapl, fila, col;
		int *offsets = get_neighbors_offset(w+n+1, 3);
		pmax = w*h;
		int dif_fila_col = (n+1)/2;
		for (p=0;p<pmax;p++){
			fila = ((int)(p/w));
			col = p-(w*fila) + dif_fila_col;
			fila += dif_fila_col;
			ind_en_lapl = col + (w+n+1)*fila;
			double *n3 = get_neighborhood(laplacian, ind_en_lapl, 3, offsets);
			if ((n3[3]*n3[5]<0)&&(abs(n3[3]-n3[5])>(tzc*max_l))) {
				// horizontal sign change
				zero_cross[p] = 255;
			} else if ((n3[1]*n3[7]<0)&&(abs(n3[1]-n3[7])>(tzc*max_l))) {
					// vertical sign change
					zero_cross[p] = 255;
				} else if ((n3[2]*n3[6]<0)&&(abs(n3[2]-n3[6])>(tzc*max_l))) {
						// +45deg sign change
						zero_cross[p] = 255;
					} else if ((n3[0]*n3[8]<0)&&(abs(n3[0]-n3[8])>(tzc*max_l))) {
							// -45deg sign change
							zero_cross[p] = 255;
						}
			free_neighborhood(n3);
		}
		free_neighbors_offsets(offsets);
\end{lstlisting}
\vspace{1ex}
\normalsize
	Save output image (using \textit{iio}): \\
\small
\begin{lstlisting}
		iio_save_image_float_vec(argv[6], zero_cross, w, h, 1);
\end{lstlisting}
\vspace{1ex}
\normalsize
	\textit{Note: the main function in \texttt{test\_mh\_log.c} is essentially the same. The only difference is that a LoG kernel is generated (instead of a Gaussian kernel) using the
	\texttt{LoG\_kernel} function in \texttt{gaussian\_kernel.c}. Therefore there is no need to use the laplacian operator, so only one convolution is made.} \\
